"""Base tool class for ReTileUp image processing tools.

This module provides the abstract base class and data models for all image processing
tools in the ReTileUp framework. It defines the standard interface that all tools
must implement to ensure consistency and interoperability.
"""

import time
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Any, Dict, List, Optional, Type, Union

from pydantic import BaseModel, ConfigDict, Field, field_validator


class ToolResult(BaseModel):
    """Result of tool execution with comprehensive metadata.

    This class encapsulates the complete result of a tool execution,
    including success status, output files, performance metrics, and
    any additional metadata that may be useful for debugging or
    workflow coordination.

    Attributes:
        success: Whether the tool execution completed successfully
        message: Human-readable status or error message
        output_files: List of output files generated by the tool
        metadata: Additional metadata about the execution
        execution_time: Time taken to execute the tool in seconds
        error_code: Optional error code for structured error handling
    """

    success: bool = Field(
        ...,
        description="Whether the tool execution completed successfully"
    )
    message: str = Field(
        ...,
        description="Human-readable status or error message"
    )
    output_files: List[Path] = Field(
        default_factory=list,
        description="List of output files generated by the tool"
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional metadata about the execution"
    )
    execution_time: Optional[float] = Field(
        None,
        description="Time taken to execute the tool in seconds",
        ge=0.0
    )
    error_code: Optional[str] = Field(
        None,
        description="Optional error code for structured error handling"
    )

    model_config = ConfigDict(extra="forbid", validate_assignment=True)

    @field_validator('output_files')
    @classmethod
    def validate_output_files(cls, v: List[Path]) -> List[Path]:
        """Validate that output file paths are valid."""
        validated_files = []
        for path in v:
            if not isinstance(path, Path):
                path = Path(path)
            validated_files.append(path)
        return validated_files


class ToolConfig(BaseModel):
    """Base configuration for all tools with common parameters.

    This class provides the standard configuration interface that all tools
    inherit from. It includes common parameters like input/output paths,
    execution options, and validation settings.

    Attributes:
        input_path: Path to the input file or directory
        output_dir: Directory for output files (optional)
        dry_run: If True, show what would be done without executing
        verbose: Enable verbose output during execution
        preserve_metadata: Whether to preserve image metadata
        timeout: Maximum execution time in seconds
    """

    input_path: Path = Field(
        ...,
        description="Path to the input file or directory"
    )
    output_dir: Optional[Path] = Field(
        None,
        description="Directory for output files (optional)"
    )
    dry_run: bool = Field(
        False,
        description="If True, show what would be done without executing"
    )
    verbose: bool = Field(
        False,
        description="Enable verbose output during execution"
    )
    preserve_metadata: bool = Field(
        True,
        description="Whether to preserve image metadata"
    )
    timeout: Optional[float] = Field(
        None,
        description="Maximum execution time in seconds",
        ge=0.1
    )

    model_config = ConfigDict(extra="forbid", validate_assignment=True)

    @field_validator('input_path')
    @classmethod
    def validate_input_path(cls, v: Path) -> Path:
        """Validate that input path is provided."""
        if not isinstance(v, Path):
            v = Path(v)
        return v

    @field_validator('output_dir')
    @classmethod
    def validate_output_dir(cls, v: Optional[Path]) -> Optional[Path]:
        """Validate and normalize output directory path."""
        if v is not None and not isinstance(v, Path):
            v = Path(v)
        return v


class BaseTool(ABC):
    """Abstract base class for all image processing tools.

    This class defines the standard interface that all ReTileUp tools must
    implement. It provides a consistent API for tool discovery, configuration
    validation, and execution.

    The tool interface is designed to be both simple for basic use cases and
    extensible for complex processing workflows. All tools must provide:

    1. Metadata describing the tool's capabilities
    2. Configuration schema validation
    3. Core execution logic
    4. Optional setup and cleanup methods

    Example:
        class MyTool(BaseTool):
            @property
            def name(self) -> str:
                return "mytool"

            @property
            def description(self) -> str:
                return "Description of what my tool does"

            @property
            def version(self) -> str:
                return "1.0.0"

            def get_config_schema(self) -> Type[ToolConfig]:
                return MyToolConfig

            def validate_config(self, config: ToolConfig) -> List[str]:
                # Validation logic here
                return []

            def execute(self, config: ToolConfig) -> ToolResult:
                # Tool execution logic here
                return ToolResult(success=True, message="Done")
    """

    def __init__(self) -> None:
        """Initialize the tool.

        Subclasses should call super().__init__() and perform any
        additional initialization required.
        """
        self._setup_called = False
        self._cleanup_called = False

    @property
    @abstractmethod
    def name(self) -> str:
        """Tool name for CLI and registry identification.

        This should be a short, unique identifier that can be used
        in CLI commands and configuration files. Use lowercase with
        hyphens for consistency (e.g., 'image-resize', 'tile-extract').

        Returns:
            Unique tool name string
        """
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Tool description for help text and documentation.

        This should be a concise, human-readable description of what
        the tool does. It will be displayed in help text and tool
        listings.

        Returns:
            Human-readable tool description
        """
        pass

    @property
    @abstractmethod
    def version(self) -> str:
        """Tool version for compatibility checking.

        Should follow semantic versioning (MAJOR.MINOR.PATCH).
        This is used for dependency resolution and compatibility
        checking in workflows.

        Returns:
            Version string in semver format
        """
        pass

    @abstractmethod
    def get_config_schema(self) -> Type[ToolConfig]:
        """Get the configuration schema class for this tool.

        This method should return the Pydantic model class that
        defines the configuration parameters for this tool. The
        returned class should inherit from ToolConfig.

        Returns:
            Pydantic model class for tool configuration
        """
        pass

    @abstractmethod
    def validate_config(self, config: ToolConfig) -> List[str]:
        """Validate tool configuration and return any errors.

        This method performs tool-specific validation beyond what
        Pydantic can provide. It should check business logic,
        file existence, parameter combinations, etc.

        Args:
            config: Tool configuration to validate

        Returns:
            List of error messages (empty if valid)
        """
        pass

    @abstractmethod
    def execute(self, config: ToolConfig) -> ToolResult:
        """Execute the tool with the given configuration.

        This is the main entry point for tool execution. It should:
        1. Perform the actual processing
        2. Handle errors gracefully
        3. Return a comprehensive result

        The method should measure execution time and include it
        in the result metadata.

        Args:
            config: Validated tool configuration

        Returns:
            Result of tool execution with metadata
        """
        pass

    def setup(self) -> None:
        """Optional setup before execution.

        This method is called before execute() and can be used to
        prepare resources, validate environment, etc. It's called
        automatically by the framework when needed.

        Subclasses should call super().setup() to ensure proper
        initialization tracking.
        """
        self._setup_called = True

    def cleanup(self) -> None:
        """Optional cleanup after execution.

        This method is called after execute() completes (whether
        successful or not) and can be used to release resources,
        clean up temporary files, etc.

        Subclasses should call super().cleanup() to ensure proper
        cleanup tracking.
        """
        self._cleanup_called = True

    def execute_with_timing(self, config: ToolConfig) -> ToolResult:
        """Execute the tool with automatic timing and lifecycle management.

        This method wraps the execute() method with timing measurement
        and automatic setup/cleanup calls. It's the recommended way
        to run tools in production.

        Args:
            config: Validated tool configuration

        Returns:
            Result of tool execution with timing information
        """
        start_time = time.time()

        try:
            # Ensure setup is called
            if not self._setup_called:
                self.setup()

            # Execute the tool
            result = self.execute(config)

            # Add timing information
            execution_time = time.time() - start_time
            result.execution_time = execution_time

            # Add timing to metadata if not already present
            if 'execution_time_ms' not in result.metadata:
                result.metadata['execution_time_ms'] = execution_time * 1000

            return result

        finally:
            # Ensure cleanup is called
            if not self._cleanup_called:
                self.cleanup()

    def __str__(self) -> str:
        """String representation of the tool."""
        return f"{self.name} v{self.version}"

    def __repr__(self) -> str:
        """Detailed string representation of the tool."""
        return (
            f"<{self.__class__.__name__}("
            f"name='{self.name}', "
            f"version='{self.version}'"
            f")>"
        )